/***/

// shim for using process in browser

// cached from whatever global is present so that test runners that stub it

// don't break things.  But we need to wrap it in a try catch in case it is

// wrapped in strict mode code which doesn't define any globals.  It's inside a

// function because try/catches deoptimize in certain engines.

//normal enviroments in sane situations

// if setTimeout wasn't available but was latter defined

// when when somebody has screwed with setTimeout but no I.E. maddness

// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error

// if clearTimeout wasn't available but was latter defined

// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally

// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.

// Some versions of I.E. have different rules for clearTimeout vs setTimeout

// v8 likes predictible objects

// empty string to avoid regexp issues

// used by devtools to display a router-view badge

// directly use parent context's createElement() function

// so that components rendered by router-view can resolve named slots

// render previous view if the tree is inactive and kept-alive

// render empty node if no matched route

// attach instance registration hook

// this will be called in the instance's injected lifecycle hooks

// val could be undefined for unregistration

// also register instance in prepatch hook

// in case the same component instance is reused across different routes

// register instance in init hook

// in case kept-alive component be actived when routes changed

// resolve props

/*  */

// clone to prevent mutation

// pass non-declared props as attrs

// the starting route that represents the initial state

// handle null value #1566

// check nested equality

// work around weird flow bug

// find the first <a> child and apply listener and href

// in case the <a> is a static node

// doesn't have <a> child, apply listener to self

// don't redirect with control keys

// don't redirect on right click

// don't redirect if `target="_blank"`

// this may be a Weex event which doesn't have this method

// don't redirect when preventDefault called

// remove trailing segment if:

// - not appending

// - appending to trailing slash (last segment is empty)

// resolve relative path

// ensure leading slash

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */

// Match escaped characters that would otherwise appear in future matches.

// This allows the user to escape special characters that won't transform.

// Match Express-style parameters and un-named parameters with a prefix

// and optional suffixes. Matches appear as:

//

// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]

// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]

// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]

/**
 * Expose `pathToRegexp`.
 */

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */

// Ignore already escaped sequences.

// Push the current path onto the tokens.

// Match any characters still remaining.

// If the path exists, push it onto the end.

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */

/**
 * Expose a method for transforming tokens into the path function.
 */

// Compile all the patterns before compilation.

// Compile all the tokens into regexps.

// Prepend partial segment prefixes.

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */

/** @type {!Object} */

// Iterate over the tokens and create our regexp string.

// In non-strict mode we allow a slash at the end of match. If the path to

// match already ends with a slash, we remove it for consistency. The slash

// is valid at the end of a path match, not in the middle. This is important

// in non-ending mode, where "/test/" shouldn't match "/test//route".

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */

// Use a negative lookahead to match only capturing groups.

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */

/** @type {!Array} */

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */

/** @type {string} */

// $flow-disable-line

// Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}

// delete the 0 if it was added

// the path list is used to control path matching priority

// ensure wildcard routes are always at the end

// named target

// relative params

// no match

// resolved named direct

// Fix #1994: using * with props: true generates a param named 0

// Fix for #1585 for Firefox

// Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678

// wait until re-render finishes before scrolling

// use User Timing api (if present) for more accurate key precision

// try...catch the pushState call to get around Safari

// DOM Exception 18 where it limits to 100 pushState calls

// if it's a function and doesn't have cid attached,

// assume it's an async component resolve function.

// we are not using Vue's default async resolving mechanism because

// we want to halt the navigation until the incoming component has been

// resolved.

// in Webpack 2, require.ensure now also returns a Promise

// so the resolve/reject functions may get called an extra time

// if the user uses an arrow function shorthand that happens to

// return that Promise.

// save resolved on async factory in case it's used elsewhere

// new syntax in Vue 2.3

// respect <base> tag

// strip full URL origin

// make sure there's the starting slash

// remove trailing slash

// start with a route object that stands for "nowhere"

// extend now so that global mixins are applied.

// fire ready cbs once

// in the case the route map has been dynamically appended to

// in-component leave guards

// global before hooks

// in-component update hooks

// in-config enter guards

// async components

// next(false) -> abort navigation, ensure current URL

// next('/') or next({ path: '/' }) -> redirect

// confirm transition and pass on the value

// #750

// if a router-view is wrapped with an out-in transition,

// the instance may not have been registered at this time.

// we will need to poll for registration until current route

// is no longer valid.

// somehow flow cannot infer this is a function

/*@__PURE__*/

// Avoiding first `popstate` event dispatched in some browsers but first

// history route not updated since async guard at the same time.

// check history fallback deeplinking

// this is delayed until the app mounts

// to avoid the hashchange listener being fired too early

// We can't use window.location.hash here because it's not

// consistent across browsers - Firefox will pre-decode it!

// empty path

// decode the hash but not the search or hash

// as search(query) is already decoded

// https://github.com/vuejs/vue-router/issues/2708

// noop

/* Vue component instance */

// main app previously initialized

// return as we don't need to set up new history listener

// set up app destroyed handler

// https://github.com/vuejs/vue-router/issues/2639

// clean out app from this.apps array once destroyed

// ensure we still have a main app or null if no apps

// we do not release the router so it can be reused

// for backwards compat

// use the same hook merging strategy for route hooks

/* harmony default export */

/* harmony export (binding) */

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */

/**
 * forEach for object
 */

// Store some children item

// Store the origin module object which passed by programmer

// Store the origin module's state

// Base data struct for store's module, package with some attribute and method

// register root module (Vuex.Store options)

// update target module

// update nested modules

// register nested modules

// bind on install

// Auto install if it is not done yet and `window` has `Vue`.

// To allow users to avoid auto-installation in some cases,

// this code should be placed here. See #731

// store internal state

// bind commit and dispatch to self

// strict mode

// init root module.

// this also recursively registers all sub-modules

// and collects all module getters inside this._wrappedGetters

// initialize the store vm, which is responsible for the reactivity

// (also registers _wrappedGetters as computed properties)

// apply plugins

// init all modules

// reset vm

// bind store public getters

// use computed to leverage its lazy-caching mechanism

// use a Vue instance to store the state tree

// suppress warnings just in case the user has added

// some funky global mixins

// enable strict mode for new vm

// dispatch changes in all subscribed watchers

// to force getter re-evaluation for hot reloading.

// set state

// register in namespace map

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */

// getters and state object must be gotten lazily

// because they will be changed by vm update

// skip if the target getter is not match this namespace

// extract local getter type

// Add a port to the getters proxy.

// Define as getter property because

// we do not want to evaluate the getters in this time.

// local state

// local getters

// root state

/**
 * vuex v3.1.0
 * (c) 2019 Evan You
 * @license MIT
 */

// override init and inject vuex init procedure

// for 1.x backwards compatibility.

/**
   * Vuex init hook, injected into each instances init hooks list.
   */

// store injection

/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */

// check object-style commit

// check object-style dispatch

// reset store to update getters...

// mark vuex getter for devtools

// Get the commit method from store

// The namespace has been mutated by normalizeNamespace

// get dispatch function from store

/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept anthor params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */

/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */

/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */

/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */

// This works in non-strict mode

// This works if eval is allowed (see CSP)

// This works if the window reference is available

// g can still be undefined, but nothing to do about it...

// We return undefined, instead of nothing here, so it's

// easier to handle this case. if(!global) { ...}

/* WEBPACK VAR INJECTION */

// Spec says greater than zero

// Don't get fooled by e.g. browserify environments.

// The test against `importScripts` prevents this implementation from being installed inside a web worker,

// where `global.postMessage` means something completely different and can't be used for this purpose.

// For non-IE10 modern browsers

// For web workers, where supported

// For IE 6â€“8

// Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted

// into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.

// Callback can either be a function or a string

// Copy function arguments

// Store and register the task

// From the spec: "Wait until any invocations of this algorithm started before this one have completed."

// So if we're currently running a task, we'll need to delay this invocation.

// Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a

// "too much recursion" error.

// DOM APIs, for completeness

// Does not start the time, just sets up the members needed.

// setimmediate attaches itself to the global object

// On some exotic environments, it's not clear which object `setimmediate` was

// able to install onto.  Search each possibility in the same order as the

// `setimmediate` library.

/*!
 * Vue.js v2.6.10
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */

// These helpers produce better VM code in JS engines due to their

// explicitness and function inlining.

/**
 * Check if value is primitive.
 */

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */

/**
 * Get the raw type string of a value, e.g., [object Object].
 */

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */

/**
 * Check if val is a valid array index.
 */

/**
 * Convert a value to a string that is actually rendered.
 */

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */

/**
 * Check if a tag is a built-in tag.
 */

/**
 * Check if an attribute is a reserved attribute.
 */

/**
 * Remove an item from an array.
 */

/**
 * Check whether an object has the property.
 */

/**
 * Create a cached version of a pure function.
 */

/**
 * Camelize a hyphen-delimited string.
 */

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */

/**
 * Convert an Array-like object to a real Array.
 */

/**
 * Mix properties into target object.
 */

/**
 * Merge an Array of Objects into a single Object.
 */

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */

/**
 * Always return false.
 */

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */

/**
 * Ensure a function is called only once.
 */

/**
   * Option merge strategies (used in core/util/options)
   */

/**
   * Whether to suppress warnings.
   */

/**
   * Show production mode tip message on boot?
   */

/**
   * Whether to enable devtools
   */

/**
   * Whether to record perf
   */

/**
   * Error handler for watcher errors
   */

/**
   * Warn handler for watcher warns
   */

/**
   * Ignore certain custom elements
   */

/**
   * Custom user key aliases for v-on
   */

/**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */

/**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */

/**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */

/**
   * Get the namespace of an element
   */

/**
   * Parse the real tag name for the specific platform.
   */

/**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */

/**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */

/**
   * Exposed for legacy reasons
   */

/**
 * Define a property.
 */

/**
 * Parse simple path.
 */

// can we use __proto__?

// Browser environment sniffing

// https://github.com/facebook/flow/issues/285

// this needs to be lazy-evaled because vue may be required before

// vue-server-renderer can set VUE_ENV

/* istanbul ignore if */

// detect devtools

// use native Set when available.

// stabilize the subscriber list first

// The current target watcher being evaluated.

// This is globally unique because only one watcher

// can be evaluated at a time.

// DEPRECATED: alias for componentInstance for backwards compat.

// optimized shallow clone

// used for static nodes and slot nodes because they may be reused across

// multiple renders, cloning them avoids errors when DOM manipulations rely

// on their elm reference.

// #7975

// clone children array to avoid mutating original in case of cloning

// a child.

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

/**
 * Intercept mutating methods and emit events
 */

// cache original method

// notify change

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */

/* eslint-disable no-proto */

/* eslint-enable no-proto */

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */

/**
 * Define a reactive property on an Object.
 */

// cater for pre-defined getter/setters

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */

/* eslint-disable no-self-compare */

/* eslint-enable no-self-compare */

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */

/**
 * Delete a property and trigger change if necessary.
 */

/**
 * Observe a list of Array items.
 */

/**
 * Options with restrictions
 */

/**
 * Helper that recursively merges two data objects together.
 */

// in case the object is already observed...

/**
 * Data
 */

// instance merge

// in a Vue.extend merge, both should be functions

/**
 * Hooks and props are merged as arrays.
 */

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */

// work around Firefox's Object.prototype.watch...

/**
 * Other object hashes.
 */

/**
 * Default strategy.
 */

/**
 * Validate component names
 */

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */

// Apply extends and mixins on the child options,

// but only if it is a raw options object that isn't

// the result of another mergeOptions call.

// Only merged options has the _base property.

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */

/**
 * Normalize all injections into Object-based format
 */

/**
 * Normalize raw function directives into object format.
 */

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */

// check local registration variations first

// fallback to prototype chain

// only cast empty string / same name to boolean if

// boolean has higher priority

// check default value

/**
 * Get the default value of a prop.
 */

// no default, return undefined

// warn against non-factory defaults for Object & Array

// the raw prop value was also undefined from previous render,

// return previous default value to avoid unnecessary watcher trigger

// call factory function for non-Function types

// a value is Function if its prototype is function even across different execution context

/**
 * Assert whether a prop is valid.
 */

// since the default value is a fresh copy,

// make sure to observe it.

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */

// Deactivate deps tracking while processing error handler to avoid possible infinite rendering.

// See: https://github.com/vuejs/vuex/issues/1505

// issue #9511

// avoid catch triggering multiple times when nested calls

// if the user intentionally throws the original error in the handler,

// do not log it twice

/* istanbul ignore else */

// Here we have async deferring wrappers using microtasks.

// In 2.5 we used (macro) tasks (in combination with microtasks).

// However, it has subtle problems when state is changed right before repaint

// (e.g. #6813, out-in transitions).

// Also, using (macro) tasks in event handler would cause some weird behaviors

// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).

// So we now use microtasks everywhere, again.

// A major drawback of this tradeoff is that there are some scenarios

// where microtasks have too high a priority and fire in between supposedly

// sequential events (e.g. #4521, #6690, which have workarounds)

// or even between bubbling of the same event (#6566).

// The nextTick behavior leverages the microtask queue, which can be accessed

// via either native Promise.then or MutationObserver.

// MutationObserver has wider support, however it is seriously bugged in

// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It

// completely stops working after triggering a few times... so, if native

// Promise is available, we will use it:

/* istanbul ignore next, $flow-disable-line */

// In problematic UIWebViews, Promise.then doesn't completely break, but

// it can get stuck in a weird state where callbacks are pushed into the

// microtask queue but the queue isn't being flushed, until the browser

// needs to do some other work, e.g. handle a timer. Therefore we can

// "force" the microtask queue to be flushed by adding an empty timer.

// PhantomJS and iOS 7.x

// Fallback to setImmediate.

// Techinically it leverages the (macro) task queue,

// but it is still a better choice than setTimeout.

// Use MutationObserver where native Promise is not available,

// e.g. PhantomJS, iOS7, Android 4.4

// (#6466 MutationObserver is unreliable in IE11)

/* not type checking this file because flow doesn't play well with Proxy */

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */

// Prefixed last, checked first

// return handler return value for single handlers

// important: remove merged hook to ensure it's called only once

// and prevent memory leak

// no existing hook

// already a merged invoker

// existing plain hook

// The template compiler attempts to minimize the need for normalization by

// statically analyzing the template at compile time.

// For plain HTML markup, normalization can be completely skipped because the

// generated render function is guaranteed to return Array<VNode>. There are

// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component

// may return an Array instead of a single root. In this case, just a simple

// normalization is needed - if any child is an Array, we flatten the whole

// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep

// because functional components already normalize their own children.

// 2. When the children contains constructs that always generated nested Arrays,

// e.g. <template>, <slot>, v-for, or when the children is provided by user

// with hand-written render functions / JSX. In such cases a full normalization

// is needed to cater to all possible types of children values.

//  nested

// merge adjacent text nodes

// this is necessary for SSR hydration because text nodes are

// essentially merged when rendered to HTML strings

// convert primitive to vnode

// default key for nested array children (likely generated by v-for)

// inject is :any because flow is not smart enough to figure out cached

// #6574 in case the inject object is observed...

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */

// named slots should only be respected if the vnode was rendered in the

// same context.

// remove slot attribute if the node is resolved as a Vue slot node

// ignore slots that contains only whitespace

// fast path 1: child component re-render only, parent did not change

// expose normal slots on scopedSlots

// fast path 2: stable scoped slots w/ no normal slots to proxy,

// only need to normalize once

// avoriaz seems to mock a non-extensible $scopedSlots object

// and when that is passed down this would cause an error

// this is a slot using the new v-slot syntax without scope. although it is

// compiled as a scoped slot, render fn users would expect it to be present

// on this.$slots because the usage is semantically a normal slot.

/**
 * Runtime helper for rendering v-for lists.
 */

/**
 * Runtime helper for rendering <slot>
 */

// scoped slot

/**
 * Runtime helper for resolving filters
 */

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */

/**
 * Runtime helper for rendering static trees.
 */

// if has already-rendered static tree and not inside v-for,

// we can reuse the same tree.

// otherwise, render a fresh tree.

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */

// see flow/vnode

// the following are added in 2.6

// marker for reverse proxying v-slot without scope on this.$slots

// helper to dynamically append modifier runtime markers to event names.

// ensure only append when value is already string, otherwise it will be cast

// to string and cause the type check to miss.

// the context vm passed in is a functional context as well.

// in this case we want to make sure we are able to get a hold to the

// real context instance.

// support for compiled functional template

// exposing $options for renderStatic()

// pre-resolve slots for renderSlot()

// #7817 clone node before setting fnContext, otherwise if the node is reused

// (e.g. it was from a cached normal slot) the fnContext causes named slots

// that should not be matched to match.

// inline hooks to be invoked on component VNodes during patch

// kept-alive components, treat as a patch

// work around flow

// we know it's MountedComponentVNode but flow doesn't

// check inline-template render functions

// determine whether component has slot children

// we need to do this before overwriting $options._renderChildren.

// check if there are dynamic scopedSlots (hand-written or compiled but with

// dynamic slot names). Static scoped slots compiled from template has the

// "$stable" marker.

// has new static slots

// has old static slots

// update vm's placeholder node without re-render

// update child tree's parent

// update props

// update $attrs and $listeners hash

// these are also reactive so they may trigger child update if the child

// used them during render

// wtf flow?

// keep a copy of raw propsData

// update listeners

// resolve slots + force update if has children

// updated props

// updated listeners

// new parent vnode

// vue-router#1212

// During updates, a kept-alive component's child components may

// change, so directly walking the tree here may call activated hooks

// on incorrect children. Instead we push them into a queue which will

// be processed after the whole patch process ended.

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */

// setting _inactive to false here so that a render function can

// rely on checking whether it's in an inactive tree (e.g. router-view)

/* direct */

// plain options object: turn it into a constructor

// if at this stage it's not a constructor or an async component factory,

// reject.

// async component

// already pending

// cache resolved

// invoke callbacks only if this is not a synchronous resolve

// (async resolves are shimmed as synchronous during SSR)

// return in case resolved synchronously

// () => Promise

// return a placeholder node for async component, which is rendered

// as a comment node but preserves all the raw information for the node.

// the information will be used for async server-rendering and hydration.

// resolve constructor options in case global mixins are applied after

// component constructor creation

// transform component v-model data into props & events

// transform component v-model info (value and callback) into

// prop and event handler respectively.

// extract props

// we are only extracting raw values here.

// validation and default values are handled in the child

// component itself.

// functional component

// extract listeners, since these needs to be treated as

// child component listeners instead of DOM listeners

// replace with listeners with .native modifier

// so it gets processed during parent component patch.

// abstract components do not keep anything

// other than props & listeners & slot

// install component management hooks onto the placeholder node

// return a placeholder vnode

// flow complains about extra args which is why we use any

// wrapper function for providing a more flexible interface

// without getting yelled at by flow

// object syntax in v-bind

// in case of component :is set to falsy value

// warn against non-primitive key

// support single function children as default scoped slot

// platform built-in elements

// direct component options / constructor

// use default namespace inside foreignObject

// ref #5318

// necessary to ensure parent re-render when deep bindings like :style and

// :class are used on slot nodes

// #7573 disable dep collection when invoking lifecycle hooks

// Async edge case #6566 requires saving the timestamp when event listeners are

// attached. However, calling performance.now() has a perf overhead especially

// if the page has thousands of event listeners. Instead, we take a timestamp

// every time the scheduler flushes and use that for all event listeners

// attached during that flush.

// Async edge case fix requires storing an event listener's attach timestamp.

// Determine what event timestamp the browser is using. Annoyingly, the

// timestamp can either be hi-res (relative to page load) or low-res

// (relative to UNIX epoch), so in order to compare time we have to use the

// same timestamp type when saving the flush timestamp.

// All IE versions use low-res event timestamps, and have problematic clock

// implementations (#9632)

// if the event timestamp, although evaluated AFTER the Date.now(), is

// smaller than it, it means the event is using a hi-res timestamp,

// and we need to use the hi-res version for event listener timestamps as

// well.

/**
 * Flush both queues and run the watchers.
 */

// Sort queue before flush.

// This ensures that:

// 1. Components are updated from parent to child. (because parent is always

//    created before the child)

// 2. A component's user watchers are run before its render watcher (because

//    user watchers are created before the render watcher)

// 3. If a component is destroyed during a parent component's watcher run,

//    its watchers can be skipped.

// do not cache length because more watchers might be pushed

// as we run existing watchers

// keep copies of post queues before resetting state

// call component updated and activated hooks

/* true */

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */

// devtool hook

// options

// uid for batching

// for lazy watchers

// parse expression for getter

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */

/**
 * Evaluate the getter, and re-collect dependencies.
 */

// "touch" every property so they are all tracked as

// dependencies for deep watching

/**
 * Add a dependency to this directive.
 */

/**
 * Clean up for dependency collection.
 */

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */

// if already flushing, splice the watcher based on its id

// if already past its id, it will be run next immediately.

// queue the flush

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */

// Deep watchers and watchers on Object/Arrays should fire even

// when the value is the same, because the value may

// have mutated.

// set new value

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */

/**
 * Depend on all deps collected by this watcher.
 */

/**
 * Remove self from all dependencies' subscriber list.
 */

// remove self from vm's watcher list

// this is a somewhat expensive operation so we skip it

// if the vm is being destroyed.

// root instance props should be converted

// static props are already proxied on the component's prototype

// during Vue.extend(). We only need to proxy props defined at

// instantiation here.

// #7573 disable dep collection when invoking data getters

// proxy data on instance

// observe data

/**
 * Check if a string starts with $ or _
 */

/* asRootData */

// computed properties are just getters during SSR

// create internal watcher for the computed property.

// component-defined computed properties are already defined on the

// component prototype. We only need to define computed properties defined

// at instantiation here.

// super option changed,

// need to resolve new options.

// check if there are any late-modified/attached options (#4976)

// update base extend options

/**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */

/**
   * Class inheritance
   */

// For props and computed properties, we define the proxy getters on

// the Vue instances at extension time, on the extended prototype. This

// avoids Object.defineProperty calls for each instance created.

// allow further extension/mixin/plugin usage

// create asset registers, so extended classes

// can have their private assets too.

// enable recursive self-lookup

// keep a reference to the super options at extension time.

// later at instantiation we can check if Super's options have

// been updated.

// cache constructor

// a uid

// a flag to avoid this being observed

// merge options

// optimize internal component instantiation

// since dynamic options merging is pretty slow, and none of the

// internal component options needs special treatment.

// doing this because it's faster than dynamic enumeration.

// locate first non-abstract parent

// expose real self

// init parent attached events

// the root of the child tree

// v-once cached trees

// bind the createElement fn to this instance

// so that we get proper render context inside it.

// args order: tag, data, children, normalizationType, alwaysNormalize

// internal version is used by render functions compiled from templates

// normalization is always applied for the public version, used in

// user-written render functions.

// $attrs & $listeners are exposed for easier HOC creation.

// they need to be reactive so that HOCs using them are always updated

// resolve injections before data/props

// resolve provide after data/props

// optimize hook:event cost by using a boolean flag marked at registration

// instead of a hash lookup

// all

// array of events

// specific event

// specific handler

// Vue.prototype.__patch__ is injected in entry points

// based on the rendering backend used.

// updates

/* removeOnly */

// update __vue__ reference

// if parent is an HOC, update its $el as well

// remove self from parent

// teardown watchers

// remove reference from data ob

// frozen object may not have observer.

// call the last hook...

// invoke destroy hooks on current rendered tree

// fire destroyed hook

// turn off all instance listeners.

// remove __vue__ reference

// release circular reference (#6759)

// install runtime convenience helpers

// set parent vnode. this allows render functions to have access

// to the data on the placeholder node.

// There's no need to maintain a stack becaues all render fns are called

// separately from one another. Nested component's render fns are called

// when parent component is patched.

// if the returned array contains only a single node, allow it

// return empty vnode in case the render function errored out

// set parent

// check pattern

// not included

// excluded

// make current key freshest

// prune oldest entry

// exposed util methods.

// NOTE: these are not considered part of the public API - avoid relying on

// them unless you are aware of the risk.

// 2.6 explicit observable API

// this is used to identify the "base" constructor to extend all plain-object

// components with in Weex's multi-instance scenarios.

// additional parameters

/**
   * Create asset registration methods.
   */

// expose FunctionalRenderContext for ssr runtime helper installation

// these are reserved for web because they are directly compiled away

// during template compilation

// attributes that should be using props for binding

/**
 * Query an element selector if it's not an element already.
 */

/*#__PURE__*/

// false or null will remove the attribute but undefined will not

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

// existing directive, update

// new directive, bind

// no longer present, unbind

// clone observed objects, as the user probably wants to mutate it

// #4391: in IE9, setting type can reset value for input[type=radio]

// #6666: IE/Edge forces progress value down to 1 before setting a max

// set attribute for blank value

// e.g. <option disabled>Select one</option>

// technically allowfullscreen is a boolean attribute for <iframe>,

// but Flash expects a value of "true" when used on <embed> tag

// #7138: IE10 & 11 fires input event when setting placeholder on

// <textarea>... block the first input event and remove the blocker

// immediately.

// handle transition classes

// set the class

// in some cases, the event used has to be determined at runtime

// so we used some reserved tokens during compile.

// save current target element in closure

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp

// implementation and does not fire microtasks in between event propagation, so

// safe to exclude.

// async edge case #6566: inner click event triggers patch, event handler

// attached to outer element during patch, and triggered again. This

// happens because browsers fire microtask ticks between event propagation.

// the solution is simple: we save the timestamp when a handler is attached,

// and the handler would only fire if the event passed to it was fired

// AFTER it was attached.

// no bubbling, should always fire.

// this is just a safety net in case event.timeStamp is unreliable in

// certain weird environments...

// event is fired after handler attachment

// bail for environments that have buggy event.timeStamp implementations

// #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState

// #9681 QtWebEngine event.timeStamp is negative value

// #9448 bail if event is fired in another document in a multi-page

// electron/nw.js app, since event.timeStamp will be using a different

// starting reference

// normalize v-model event tokens that can only be determined at runtime.

// it's important to place the event as the first in the array because

// the whole point is ensuring the v-model callback gets called before

// user-attached handlers.

// IE input[type=range] only supports `change` event

// This was originally intended to fix #4521 but no longer necessary

// after 2.5. Keeping it for backwards compat with generated code from < 2.4

// ignore children if the node has textContent or innerHTML,

// as these will throw away existing DOM nodes and cause removal errors

// on subsequent patches (#3360)

// #6601 work around Chrome version <= 55 bug where single textNode

// replaced by innerHTML/textContent retains its parentNode property

// avoid resetting cursor position when value is the same

// store value as _value as well since

// non-string values will be stringified

// return true when textbox (.number and .trim) loses focus and its value is

// not equal to the updated value

// #6157

// work around IE bug when accessing document.activeElement in an iframe

// injected by v-model runtime

// IE doesn't support innerHTML for SVG elements

// skip the update if old and new VDOM state is the same.

// `value` is handled separately because the DOM value may be temporarily

// out of sync with VDOM state due to focus, composition and modifiers.

// This  #4521 by skipping the unnecesarry `checked` update.

// some property updates can throw

// e.g. `value` on <progress> w/ non-finite value

// check platforms/web/util/attrs.js acceptValue

// merge static and dynamic style data on the same vnode

// static style is pre-processed into an object during compilation

// and is always a fresh object, so it's safe to merge into it

// normalize possible array / string values into Object

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */

// Support values array created by autoprefixer, e.g.

// {display: ["-webkit-box", "-ms-flexbox", "flex"]}

// Set them one by one, and the browser will only set those it can recognize

// store normalized style under a different key for next diff

// make sure to clone it if it's reactive, since the user likely wants

// to mutate it.

// ie9 setting to null has no effect, must use empty string

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */

// binding to window is necessary to make hot reload work in IE in strict mode

// JSDOM may return undefined for transition properties

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers

// in a locale-dependent way, using a comma instead of a dot.

// If comma is not replaced with a dot, the input will be rounded down (i.e. acting

// as a floor function) causing unexpected behaviors

// call leave callback now

// remove pending leave element on enter by injecting an insert hook

// start enter transition

// call enter callback now

// the delayed leave may have already been cancelled

// record leaving element

// only used in dev mode

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */

// element may have already been removed due to v-html / v-text

// for transition enter check

// This vnode was used in a previous render!

// now it's used as a new node, overwriting its elm would cause

// potential patch errors down the road when it's used as an insertion

// reference node. Instead, we clone the node on-demand before creating

// associated DOM element for it.

// after calling the init hook, if the vnode is a child component

// it should've created a child instance and mounted it. the child

// component also has set the placeholder vnode's elm.

// in that case we can just return the element and be done.

/* hydrating */

// hack for #4339: a reactivated component with inner transition

// does not trigger because the inner node's created hooks are not called

// again. It's not ideal to involve module-specific logic in here but

// there doesn't seem to be a better way to do it.

// unlike a newly created component,

// a reactivated keep-alive component doesn't insert itself

// empty component root.

// skip all element-related modules except for ref (#3455)

// make sure to invoke the insert hook

// Reuse variable

// set scope id attribute for scoped CSS.

// this is implemented as a special case to avoid the overhead

// of going through the normal attribute patching process.

// for slot content they should also get the scopeId from the host instance.

// Text node

// we have a recursively passed down rm callback

// increase the listeners count

// directly removing

// recursively invoke hooks on child component root node

// clone reused vnode

// reuse element for static trees.

// note we only do this if the vnode is cloned -

// if the new node is not cloned it means the render functions have been

// reset by the hot-reload-api and we need to do a proper re-render.

// Vnode moved right

// Vnode moved left

// New element

// same key but different element. treat as new element

// delay insert hooks for component root nodes, invoke them after the

// element is really inserted

// list of modules that can skip create hook during hydration because they

// are already rendered on the client or has no need for initialization

// Note: style is excluded because it relies on initial clone for future

// deep updates (#7063).

// Note: this is a browser-only function so we can assume elms are DOM nodes.

// assert node match

// child component. it should have hydrated its own tree.

// empty element, allow client to pick up and populate children

// v-html and domProps: innerHTML

// iterate and compare children lists

// if childNode is not null, it means the actual childNodes list is

// longer than the virtual children list.

// ensure collecting deps for deep class bindings for future updates

// empty mount (likely as component), create new root element

// patch existing root node

// mounting to a real element

// check if this is server-rendered content and if we can perform

// a successful hydration.

// either not server-rendered, or hydration failed.

// create an empty node and replace it

// replacing existing element

// update parent placeholder node element, recursively

// create new node

// extremely rare edge case: do not insert if old element is in a

// leaving transition. Only happens when combining transition +

// keep-alive + HOCs. (#4590)

// #6513

// invoke insert hooks that may have been merged by create hooks.

// e.g. for directives that uses the "inserted" hook.

// start at index 1 to avoid re-invoking component mounted hook

// destroy old node

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

// http://www.matts411.com/post/internet-explorer-9-oninput/

// #6903

// Safari < 10.2 & UIWebView doesn't fire compositionend when

// switching focus before confirming composition choice

// this also fixes the issue where some browsers e.g. iOS Chrome

// fires "change" instead of "input" on autocomplete.

// in case the options rendered by v-for have changed,

// it's possible that the value is out-of-sync with the rendered options.

// detect such cases and filter out values that no longer has a matching

// option in the DOM.

// prevent triggering an input event for no reason

// recursively search for possible transition defined inside the component root

// in case the child is also an abstract component, e.g. <keep-alive>

// we want to recursively retrieve the real component to be rendered

// props

// events.

// extract listeners and pass them directly to the transition methods

// filter out text nodes (possible whitespaces)

// warn invalid mode

// if this is a component root node and the component's

// parent container node also has transition, skip.

// apply transition data to child

// use getRealChild() to ignore abstract components e.g. keep-alive

// ensure a key that is unique to the vnode type and to this transition

// component instance. This key will be used to remove pending leaving nodes

// during entering.

// mark v-show

// so that the transition module can hand over the control to the directive

// replace old child transition data with fresh one

// important for dynamic transitions!

// handle transition mode

// return placeholder node and queue update when leave finishes

// warn multiple elements

// force removing pass

// hydrating

// we divide the work into three loops to avoid mixing DOM reads and writes

// in each iteration - which helps prevent layout thrashing.

// force reflow to put everything in position

// assign to this to avoid being removed in tree-shaking

// Detect whether an element with the move class applied has

// CSS transitions. Since the element may be inside an entering

// transition at this very moment, we make a clone of it and remove

// all other transition classes applied to ensure only the move class

// is applied.

// install platform specific utils

// basic support for MathML

// note it doesn't support other MathML elements being component roots

// install platform runtime directives & components

// install platform patch function

// public mount method

// we set this to vm._watcher inside the watcher's constructor

// since the watcher's initial patch may call $forceUpdate (e.g. inside child

// component's mounted hook), which relies on vm._watcher being already defined

/* isRenderWatcher */

// manually mounted instance, call mounted on self

// mounted is called for render-created child components in its inserted hook

// devtools global hook
